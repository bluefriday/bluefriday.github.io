{"meta":{"title":"오늘처럼","subtitle":"test","description":"test","author":"Heechang Lee","url":"http://bluefriday.github.io","root":"/"},"pages":[],"posts":[{"title":"dockerfile best practice","slug":"dockerfile-best-practice","date":"2020-11-19T00:38:28.000Z","updated":"2020-11-19T09:41:09.145Z","comments":true,"path":"2020/11/19/dockerfile-best-practice/","link":"","permalink":"http://bluefriday.github.io/2020/11/19/dockerfile-best-practice/","excerpt":"","text":"Dockerfile Best Practice도커 컨테이너를 만들기 위해 사용되는 도커 이미지는 Dockerfile 을 통해서 생성할 수 있다. 물론 commit 명령어를 이용하여 동적으로 컨테이너로부터 이미지를 생성할 수도 있지만, 이미지의 효율적인 관리를 위해서 commit을 사용하는 것보다는 Dockerfile 을 이용하여 이미지를 생성하는 것이 좋다. 여기서는 Dockerfile을 작성할 때 유의해야 하는 사항들에 대하여 정리한다. (해당 내용은 https://docs.docker.com/develop/develop-images/dockerfile_best-practices/ 의 링크를 참조하였습니다.) 설치 구성의 최소화컨테이너는 효율적인 리소스 사용 및 배포의 자동화를 위해, 사용량을 고려하여 손쉽게 scale in/out 될 수 있는 구조다. 따라서 해당 컨테이너가 필요에 따라 생성되거나 삭제될 수 있다는 점을 고려하여, 컨테이너에 필요 이상의 설정을 하지 않고 최소한의 설정/구성으로 구동할 것을 권장한다. 복잡성/의존성을 최소화하기 위하여 해당 이미지에서 구동되는 어플리케이션에 필요한 최소한의 library 만을 설치하는 것이 좋다. 또한 컨테이너가 삭제될 경우 컨테이너 내부의 데이터도 함께 삭제되기 때문에, 사용자에 의해 변경되거나 기록될 수 있는 데이터는 VOLUME 명령어를 이용하여 외부에 적재하는 것이 좋다. ‘.dockerignore’ 파일의 활용빌드 작업을 수행할 때 docker engine은 build script 파일(Dockerfile)이 있는 경로와 모든 하위 경로의 파일/디렉토리를 임시 공간(Docker context)에 저장한 후 build 작업을 수행한다. 이 경우 docker build 에 직접적으로 사용되지 않더라도 해당 경로 하위에 있는 파일/디렉토리가 context에 포함될 수 있다. 이를 방지하기 위하여 .dockerignore 파일을 이용하여 빌드 시에 제외할 파일/디렉토리를 지정할 수 있다. 빌드 되는 컨테이너 이미지의 기능 차이는 없으나, 빌드 성능을 높이기 위하여 build 가 이루어지는 디렉토리에서 .dockerignore 파일을 생성하여 활용하는것을 권장한다. 물론 가장 좋은 방법은 빈 디렉토리를 생성한 후에 Dockerfile과 build에 반드시 필요한 파일/디렉토리만을 해당 디렉토리 내부에 위치하여 container 이미지를 생성하는 방법이다. 1 application per 1 container컨테이너 안에 2개 이상의 어플리케이션을 구동하는 것도 물론 가능하다. 예를 들어 web, was 어플리케이션을 하나의 컨테이너 안에서 구동되도록 할 수도 있다. 하지만 이렇게 1개의 컨테이너 안에 2개 이상의 어플리케이션을 구동하여 사용하는 것은, 컨테이너로 구동되어 있는 어플리케이션 간의 결합성을 높이고 확장성을 떨어트린다. 가령 앞의 경우 web 어플리케이션만 scaling이 되어도 충분한 상황에서 was까지 추가적으로 구동이 될 수 밖에 없다. 자원의 효율적인 확장을 위하여 1개의 컨테이너 안에 웹서버, 데이터베이스 등을 모두 설치하여 사용하는 방식을 지양해야 한다. Dockerfile 스크립트 최소화Docker 이미지의 구성 레이어 수는 Dockerfile 의 예약어 수에 비례한다. 가독성을 높이기 위하여 Dockerfile의 예약어를 여러 라인에 걸쳐 사용할 수 있지만, 레이어의 수가 증가하여 파일크기, 빌드시간 등이 늘어날 수 있으므로 가독성과 이미지 크기를 적절히 고려하여 Dockerfile 스크립트를 구성해야 한다. Caching 기능 활용빌드 시간을 단축하기 위하여 Docker build 엔진의 캐싱 기능을 활용할 수 있다. build engine은 한번 이상 빌드한 Dockerfile의 이미지를 Dockerfile 기준 스크립트 라인 단위로 캐싱 한다. 변경되지 않은 라인의 경우 기존의 캐싱 데이터를 이용하므로, 자주 변경될 수 있는 예약어의 경우 Dockerfile의 하단에 위치하는 것이 좋다. 또한 이와는 반대로 캐싱 기능을 아예 사용하지 않을 경우도 있다. 이 경우에는 FROM 절 바로 밑의 하단에 ENV 변수로 CACHE_TEMP 등의 변수명을 지정해주고 빌드를 할 때, 이 변수의 값을 임의의 난수로 지정해주면 된다. 해당 변수는 컨테이너 이미지 안에서 사용되지 않고, 의미없는 변수로 남게 되지만 Dockerfile의 해당 라인이 변경되었으므로 build engine은 FROM 절 바로 밑 라인부터 캐시를 사용하지 않고 다시 빌드를 수행할 수 있다. Command instructionFROMBase 이미지의 경우 docker hub에서 제공하는 official 이미지를 사용하는 것을 권장한다. official 이미지는 docker principle 에 따라 최소한의 설치 요소로 구성되어 있다. 이 외에도 자주 사용하는 라이브러리가 있을 경우, 자신에게 커스터마이징 된 이미지를 미리 생성해놓고 해당 이미지를 base 이미지로 사용하는 것도 좋은 방법이다. ENVENV 예약어는 구동 되어질 컨테이너 내부의 환경변수를 정의한다. WORKDIR, USER 등의 명령어를 조합하여 사용하지 않는 경우, 환경변수 PATH에 어플리케이션의 경로를 추가하여 구동 시 임의의 위치에서 명령어가 실행 될 수 있도록 지정할 수 있다. 또한 환경변수로 설치된 어플리케이션의 major, minor version을 명시하거나, 이미지 생성일시 등을 기록해두면 직관성을 높이고 유지보수에도 도움이 된다. 또한 위에 서술한 내용과 같이 Dockerfile 의 cache를 없애고 싶을 때도 활용할 수 있다. ADD, COPY 명령어ADD, COPY는 모두 이미지 build가 이뤄지는 호스트 환경의 파일을 컨테이너 내부로 복사한다는 점에서는 동일한 기능을 수행하지만, 세부적인 기능에서 차이가 있으므로 이를 구분하고 적절하게 사용하는 것이 좋다. COPY 예약어는 host 환경의 파일, 디렉토리를 대상 컨테이너 이미지 안으로 복사하는 기능만을 수행한다. 이에 비해 ADD 예약어는 2가지 기능을 추가로 제공한다. 첫번째로 제공하는 기능은 ‘Auto-extraction’ 기능이며 이는 복사하는 대상 파일이 압축 파일(tar, tar.gz)일 경우, 해당 파일의 압축을 해제하여 복사해준다. 또한 ‘Remote-URL’ 기능을 제공하여 wget등을 통하여 원격지의 파일을 복사할 파일로 지정할 수 있다. 그러나 직관성이 떨어지므로, 2가지 기능을 반드시 사용해야하는 경우가 아니라면 상대적으로 직관성이 더 높은 COPY 명령어를 권장한다. RUN 명령어RUN 명령어는 컨테이너 안에서 쉘 명령어를 사용할 수 있는 예약어다. 이미지를 커스터마이징하기 위해서 매우 높은 빈도로 사용되며, Dockerfile 을 작성하면서 RUN 명령어를 사용하는 대부분의 경우는 apt-get(debian,ubuntu), yum(centos) 등을 라이브러리를 설치하기 위해 사용된다. 이 경우, 최소 구성을 위하여 자동 update 기능을 지양하는 것이 좋다. apt-get 명령어를 사용할 경우 불필요한 apt-get upgrade 등의 명령어를 사용하지 않을 것을 권장한다. upgrade 명령어를 같이 사용할 경우, 최소 구성을 위한 설치 이외의, 권장되지만(nice to have) 반드시 필요하지는 않는 라이브러리 또한 함께 설치되어 이미지 레이어 크기가 증가한다. 또한 여러 개의 라이브러리를 설치할 경우, 라이브러리 간 판별성을 높이기를 위하여 알파벳순으로 정렬한 후 개행문자()를 이용하여 여러라인으로 표시하는 것이 좋다. cachinig 방식 유의(cache busting)Docker engine은 ADD, COPY 이외의 명령어에 대하여 string 값을 비교하여 캐싱 작업을 수행한다. 예를 들어, 1214: RUN apt-get update 15: RUN apt-get install -y curl 위의 빌드 스크립트를 포함한 docker image를 생성하여 사용한 후에, 사용 뒤의 용도 변경으로 인하여 1214: RUN apt-get update 15: RUN apt-get install -y curl nginx 위와 같이 변경하였을 경우, docker engine은 14번째 라인까지 캐싱 값을 사용하여 15번째 라인부터 명령어를 수행한다. 이 경우 최신 update를 사용하지 않게 되어, nginx 가 latest버전으로 설치 되지 않을 수 있다. 설치하는 library, middle ware 의 최신화를 위화여 update 구문은 항상 114: RUN apt-get update &amp;&amp; apt-get install something... 위와 같이 파이프라인을 통하여 함께 수행하는것을 권장한다. apt, yum 캐시 제거apt-get update, apt-get install 명령어를 수행한 후에 파이프라인을 통하여 apt cache를 제거하면 레이어의 크기를 줄일 수 있다.위의 instruction을 정리하여 아래와 같은 방식으로 apt-get 명령어를 수행하는 것을 권장한다. 12345RUN apt-get update \\ &amp;&amp; apt-get install -y --no-install-recommends libjemalloc1 \\ curl \\ nginx \\ &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* Using pipes1RUN wget -O - https:&#x2F;&#x2F;some.site | wc -l &#x2F; number 위의 구문 같은 경우 wget 의 성공/실패 여부와 상관없이 그 결과 출력의 wc -l 구문 결과가 /number에 성공적으로 저장되면서 docker build engine은 이 경우 언제나 성공으로 인식한다. build 초기에 잡히는 구문 오류가 아닌, 이러한 논리적 오류을 없애기 위해선 1RUN set -o pipefail &amp;&amp; wget -O - https:&#x2F;&#x2F;some.site | wc -l &#x2F; number 이런식으로 set -o option을 같이 적용해줘야 한다.","categories":[],"tags":[]},{"title":"docker image garbage collection","slug":"docker-image-garbage-collection","date":"2020-11-19T00:32:48.000Z","updated":"2020-11-19T09:34:53.438Z","comments":true,"path":"2020/11/19/docker-image-garbage-collection/","link":"","permalink":"http://bluefriday.github.io/2020/11/19/docker-image-garbage-collection/","excerpt":"","text":"1. Docker image의 물리적 삭제Docker image는 registry 에 저장될 때 image의 레이어 단위로 저장이 되며, 이렇게 저장된 레이어는 registry 의 내부에서 manifest 파일에 의해서 참조 된다. 또한 사용되지 않는 registry 의 물리적 이미지 삭제는 Registry Garbage Collection (이하 Registry GC) 에 의해서 수행되며, Registry GC가 수행될 때 사용되지 않는(어떤 manifest파일에서도 참조하지 않는) blob 파일들이 삭제 되면서 용량이 확보된다. 단계적으로 보면 아래와 같다. mark phase : registry 내부의 manifest 를 검색하여 manifest 가 참조하고 있는 image layer 에 대하여 마킹 sweep phase : 마킹이 되어 있지 않는 image layer에 대하여 레이어 삭제 수행 하지만, 이러한 Registry GC는 자동으로 수행되지 않으며, 명시적으로 수행하여 파일을 삭제하기 위해서 아래의 작업이 필요하다. 먼저 아래와 같이 Registry Config 설정을 수정하여 삭제가 가능하도록 delete 플래그를 변경(disable -&gt; enable) 하여야 한다. 기존에 구동되어 있는 registry가 해당 플래그가 선언되어 있지 않다면, registry config 를 수정한 후에 컨테이너를 재기동하자. 이를 위해서 registry config 또한 docker volume 으로 외부 파일로 연결하는 것이 좋다. 1)그 후에 Docker registry API 를 이용하여 삭제할 image의 content-digest 를 조회한다. 그리고 2)조회한 digest 값을 이용하여 image manifest 를 삭제한다. image manifest를 삭제할 경우 논리적 삭제만 이뤄지며 실제로 물리적으로 디스크에서 이미지가 지워지지는 않는다. 물리적 삭제를 위해서 컨테이너 내부에서 ‘garbage-collect 명령어를 수행하여 Registry GC를 수동으로 수행한다. 위의 1), 2)와 명시적 gc 수행 명령어는 이 글의 최하단의 ‘관련 명령어’ 를 참조하자. 1234567891011version: 0.1... storage: delete: enabled: false (-&gt; true 로 변경)... 2. Image에 삭제에 따른 storage 용량 확보위에서 소개한 것과 같이, docker image layer는 registry 내부의 모든 manifests 파일이 참조하지 않는 레이어에 대하여만 GC 시, 삭제를 수행한다. 이와 같이 여러개의 manifests 파일이 동일한 이미지 레이어를 참조하는 구조로 인하여, 특정 이미지를 삭제 하는 것이 disk 확보와 직결되지 않을 수 있다. 아래의 그림을 예시로 보자. image A와 image B는 서로 동일한 레이어를 포함하고 있다. 이와 같은 구조는 실제 도커 이미지를 빌드할 때, 같은 베이스 이미지를 사용하여 빌드를 계속 수행할 경우 나타날 수 있다. 이런 경우에 최종 빌드 이미지만을 남겨 놓기 위하여 image A를 삭제하는 경우 image B가 참조하고 있는 layer 들로 인하여 실제로 layer a,b,c 는 삭제 되지 않는다. 이와 다른 경우로 오른쪽의 그림을 보면 하나의 베이스 이미지로 여러가지 버전이 존재 한다. image C, D, E, F 중 일부를 삭제 하는 경우 해당 image에서만 사용하고 있는 레이어도 같이 삭제하여 디스크를 확보할 수 있다. 위와 같은 이미지 레이어의 참조 구조를 고려하여 도커 이미지를 빌드하거나 혹은 삭제하는 것이 좋다. #@# 3. Caching 기능에 따른 re-push 문제위와 같은 방식을 이용하면 특정 이미지를 물리적으로 제거할 수 있다. 하지만 이렇게 Registry GC를 수행한 후에 동일한 [이미지]:[태그]로 다시 push 할 경우에는 push가 수행 되는 것처럼 보이지만 내부적으로는 실제 push가 일어나지 않는다. 따라서 push 후에 동일한 이미지명으로 pull 할 경우에도 image가 존재하지 않는다는 오류가 발생한다. 이는 docker registry config에 caching 기능이 지정되어 있어 발생한다. Registry는 image layer에 접근을 빠르게 하기 위하여 caching 기능을 기본적으로 사용하며, inmemory, redis 등의 옵션으로 사용되어진다. 이 caching 기능을 없애기 위하여 registry config 파일에서 caching 과 관련된 항목을 제거한다. 반대로 caching을 기능 없애지 않는 경우에는, cache 를 수동으로 없애기 위하여 registry 컨테이너를 재시작하는 방법 또한 가능하다. 즉, 물리적 이미지 삭제 이후에 re-push가 되지 않는 문제를 해결하기 위해서는 1) in-memory cache를 지우기 위하여 registry 컨테이너를 재시작하거나, 2)구동하는 시점부터 cache 기능을 사용하지 않도록 설정하는 방법을 사용할 수 있다. (추가적으로 캐시 저장소를 redis를 사용하는 방법이 있으나 이는 별도로 기술한다.) 하지만 cache 를 없애기 위한 위 2가지 방식과 무관하게, disk size를 줄이기 위하여 수행해야 하는 GC 수행은 반드시 registry의 image로 구동되어 있는 container가 없으며, pull/push 가 일어나지 않는 중에 수행 되어야 한다. 그렇지 않을 경우, 기존 image가 깨지거나 pull/push 중이던 image가 손상될 수 있다. 결론위의 방법 중 어떤 방법을 사용하더라도, 실제로 GC가 일어나는 중에는 registry의 기능이 정지되어 있어야 한다. 어차피 GC를 위하여 registry의 기능을 사용하지 않는다면, 캐싱기능을 그대로 사용하고 registry를 재시작하는 방법을 권장한다. 결과적으로 registry 삭제를 통한 disk 확보는 docker image 의 multi-layer 구조를 고려하여 진행하는 것이 좋으며, 삭제하지 않을 경우에는 처음부터 충분한 공간의 storage를 확보하는 것이 좋다. 관련 명령어registry 와 관련된 API를 활용한 명령어는 아래와 같으며, 아래의 순서대로 차례대로 명령을 수행하여 해당 이미지를 논리적/물리적으로 삭제할 수 있다. 123456789101112131401. registry 내부의 repository 정보 조회$ curl -X GET &lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;_catalog02. repository 에 대하여 tag 정보 조회$ curl -X GET &lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;tags&#x2F;list03. content digest 조회$ curl -v --silent -H &quot;Accept: application&#x2F;vnd.docker.distribution.manifest.v2+json&quot; -X GET http:&#x2F;&#x2F;&lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;manifests&#x2F;&lt;TAG 이름&gt; 2&gt;&amp;1 | grep Docker-Content-Digest | awk &#39;&#123;print ($3)&#125;&#39;04. manifest 삭제$ curl -v --silent -H &quot;Accept: application&#x2F;vnd.docker.distribution.manifest.v2+json&quot; -X DELETE http:&#x2F;&#x2F;&lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;manifests&#x2F;&lt;DIGEST 정보&gt;05. GC(Garbage Collection)$ docker exec -it registry_dev registry garbage-collect &#x2F;etc&#x2F;docker&#x2F;registry&#x2F;config.yml","categories":[],"tags":[]},{"title":"docker overview","slug":"docker-overview","date":"2020-11-18T23:50:09.000Z","updated":"2020-11-19T09:28:19.572Z","comments":true,"path":"2020/11/18/docker-overview/","link":"","permalink":"http://bluefriday.github.io/2020/11/18/docker-overview/","excerpt":"","text":"1. Container 기술과 Docker기존의 시스템 관리자들은 서비스를 제공하는 서버를 관리하기 위하여 VM(Virtual Machine, 가상머신)을 사용하여 자원을 관리해왔다. VM을 사용하는 서버 관리 방식은 물리적 서버를 직접 운영하는 것보다 효율적이었지만, Host OS 위에 Guest OS를 구동하는 구조로 인하여 가상화(hypervisor 레이어) 자체에 대한 비용이 존재하였다. 또한 서비스의 규모가 커지거나, 사용시간 등에 따라 사용량이 수시로 변경되면서 자원을 효율적으로 관리하기 위한 스케일에 대한 필요성도 증가하였다. 이러한 환경에서 등장한 컨테이너 기술은 Guest OS를 생성하여 시스템 자체를 가상화 하는 것이 아닌, 어플리케이션의 구동 환경을 가상화 하는 기술이다. 기존에 사용하던 VM이 Host OS 위에 Hypervisor Tool 을 이용하여 Guest OS 를 구동하는 것에 비해, 컨테이너 서비스는 Host OS 위에 직접 어플리케이션의 실행환경을 가상화 시켜준다. GuestOS 가 없기 때문에 VM에 비하여 가볍고 구동시간 또한 더 빠르다. 애초에 OS가 아니라 프로세스가 구동되는 개념이어서, 부팅 속도가 VM에 비해 더 빠를 수 밖에 없다. 이러한 이유로 컨테이너는 Lightweight VM 이라고도 불린다. 빠른 부팅 속도로 인하여 스케일링, fail-over 등에도 효율적이다.또한 Hypervisor 가 없이 바로 HostOS 의 자원을 사용할 수 있기 때문에 VM에 비해 더 효율적인 자원 사용이 가능하다. 정리하면 아래와 같은 장점을 가지고 있다고 볼 수 있다. 가상화 기술보다 가볍고 성능이 좋으면서도 동일한 Bard Metal/Virtual Machine 에서 더 많은 어플리케이션을 구동할 수 있다. 빠른 빌드와 배포, 이식성을 제공하므로 이를 통해서 개발을 더 쉽고 빠르게 할 수 있고 확장성을 높힐 수 있다. 개발에서 운영으로의 이관이 용이하며, DevOps 패러다임에 유리하다. Host Kernal 레벨을 공유하며 OS를 따로 부팅하지 않으므로 VM에 비하여 부팅속도가 매우 빠르다. 그러나 실제로는 GuestOS가 없다는 표현 보다는 HostOS를 Linux 로 고정 시킨 것에 가깝기 때문에, Linux OS 가 아닌 OS. 예를 들면 windows OS 에서만 작동하는 어플리케이션은 컨테이너로 구동할 수 없다는 단점도 있다. 이러한 장점과 단점을 가진 컨테이너 기술은 사실 갑자기 등장한 개념은 아니다. 서버 관리자들은 이미 chroot, namespace 등의 컨테이너를 구성하는 프로세스 격리 기술을 사용해 왔으며 최근에 사용성이 증가되면서 ‘컨테이너’ 라는 개념으로 새롭게 조명되고 있다. 즉, ‘빅데이터’나 ‘클라우드’와 같이 마케팅 성격이 다소 포함된 개념으로 볼 수 있다. 이 블로그에서 소개하고 있는 Docker 서비스는 Linux 환경에서 컨테이너 기술을 사용하기 쉽게 만들어놓은 시스템 프로그램(서비스)이다. 내부적으로 리눅스에 내장되어 있는 OS 레벨의 가상화 기술인 리눅스 컨테이너 기술(LXC)을 사용한다. Docker와 같은 컨테이너 서비스는 Linux 에서만 존재하는 기술은 아니며 이외의 Unix / BSD 계열에서도 컨테이너라는 명칭을 사용하지 않을 뿐 아래와 같은 가상화 기술을 제공하고 있다. Linux : Docker FreeBSD : Jails AIX : 워크로드 파티션(AIX Workload Partitions) Solaris : Zone 2. Docker installDocker는 리눅스에서 제공하는 컨테이너 서비스이므로 당연히 LInux 계열의 OS 인 Debian, Centos, Ubuntu 등의 OS에서 설치하는 것이 가장 쉽고 편하다. 추가적으로 Linux 이외의 Mac OS, Windows OS 등에서도 Docker를 설치할 수 있도록 가이드와 패키지를 제공하고 있다. Windows 에서 Docker를 설치 하기 위해서는 Windows 환경 위에 Linux OS 를 Guest로 구성해야 한다. 물론 Guest OS를 사용하지 않기 위한 것이 Docker 사용의 주요 목적이므로, docker를 설치하기 위해 Guest OS를 구성하는 것은 매우 비효율적이고 부자연스러운 방식이나 실 운영 서비스를 위해서가 아닌 개발 및 검증 목적으로 설치할 경우는 이와 같은 방식으로도 설치가 가능하다. 대부분의 경우 VMWare 나 Oracle Virtualbox 등의 hypervisor tool 을 설치하고 그 위에 Linus OS(ubuntu, centos)를 GuestOS로 구동하고 다시 그 안에서 도커를 설치한다. (전술했듯이 복잡하고 성능상으로는 다소 불리한 방법이니 테스트 등의 목적으로만 사용하는 것이 좋다.) 이와는 별개로 Docker 측에서는 위와 같은 작업을 이미 packaging 화하여 ‘Docker toolbox’라는 설치 패키지를 제공한다. 실제로 Docker Toolbox 안에는 Oracle virtualBox 가 포함되어 있다. 편한 방법을 사용하여 도커를 설치하도록 하자. 또한 Windows 10의 경우 docker toolbox 이외에 Docker for windows 라는 별도의 설치패키지를 지원한다. docker toolbox와 유사하나 windows에서 제공하는 windows container 를 위한 패키지가 추가 되었다고 보면 된다. (Docker container 가 host OS 가 linux 를 사용하는 것과 반대로 Windows container 는 host OS를 Windows로 사용한다고 보면 이해가 쉽다) 각각의 OS에서 Docker를 설치하는 링크나 패키지는 아래와 같으므로 필요에 따라 해당 내용을 검색하여 설치를 권장한다. Ubuntu : https://docs.docker.com/install/linux/docker-ce/ubuntu/ Centos : https://docs.docker.com/install/linux/docker-ce/centos/ Mac OS : Docker for Mac, Docker Toolbox Windows 7 : Docker Toolbox Windows 10 : Docker for windows 3. Docker version컨테이너 개념에 대하여 소개하면서 서술하였듯이, ‘컨테이너’라는 개념은 이미 존재하고 있는 시스템 개념이며 Docker는 이를 사용하기 쉽게 패키징한 서비스이다. Docker 진영은 2013년 1월에 0.1.0 버전으로 처음 release 하여 계속해서 버그를 수정하고 새로운 기능을 계속 추가해 오다가 1.6버전에서부터 enterprise 성격의 cs-docker(cs : Commercial Supported)를 출시한다. 또한 2017년에는 그 동안의 표기인 docker, cs-docker 를 docker-ce, docker-ee로 각각 변경하고 기존의 major / minor 버전 표기법을 year.month 의 연월 표기법으로 변경하여 사용한다. Docker-CE : Community 버전. 분기별로 새로운 버전이 출시되며, 실험적인 기능을 포함하고 있는 edge 버전이 매달 release 된다.Docker-EE : Enterprise 버전. 분기별로 새로운 버전이 출시된다.","categories":[],"tags":[]}],"categories":[],"tags":[]}