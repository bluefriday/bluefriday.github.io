{"meta":{"title":"오늘처럼","subtitle":"test","description":"test","author":"Heechang Lee","url":"http://bluefriday.github.io","root":"/"},"pages":[],"posts":[{"title":"docker image garbage collection","slug":"docker-image-garbage-collection","date":"2020-11-19T00:32:48.000Z","updated":"2020-11-19T09:34:53.438Z","comments":true,"path":"2020/11/19/docker-image-garbage-collection/","link":"","permalink":"http://bluefriday.github.io/2020/11/19/docker-image-garbage-collection/","excerpt":"","text":"1. Docker image의 물리적 삭제Docker image는 registry 에 저장될 때 image의 레이어 단위로 저장이 되며, 이렇게 저장된 레이어는 registry 의 내부에서 manifest 파일에 의해서 참조 된다. 또한 사용되지 않는 registry 의 물리적 이미지 삭제는 Registry Garbage Collection (이하 Registry GC) 에 의해서 수행되며, Registry GC가 수행될 때 사용되지 않는(어떤 manifest파일에서도 참조하지 않는) blob 파일들이 삭제 되면서 용량이 확보된다. 단계적으로 보면 아래와 같다. mark phase : registry 내부의 manifest 를 검색하여 manifest 가 참조하고 있는 image layer 에 대하여 마킹 sweep phase : 마킹이 되어 있지 않는 image layer에 대하여 레이어 삭제 수행 하지만, 이러한 Registry GC는 자동으로 수행되지 않으며, 명시적으로 수행하여 파일을 삭제하기 위해서 아래의 작업이 필요하다. 먼저 아래와 같이 Registry Config 설정을 수정하여 삭제가 가능하도록 delete 플래그를 변경(disable -&gt; enable) 하여야 한다. 기존에 구동되어 있는 registry가 해당 플래그가 선언되어 있지 않다면, registry config 를 수정한 후에 컨테이너를 재기동하자. 이를 위해서 registry config 또한 docker volume 으로 외부 파일로 연결하는 것이 좋다. 1)그 후에 Docker registry API 를 이용하여 삭제할 image의 content-digest 를 조회한다. 그리고 2)조회한 digest 값을 이용하여 image manifest 를 삭제한다. image manifest를 삭제할 경우 논리적 삭제만 이뤄지며 실제로 물리적으로 디스크에서 이미지가 지워지지는 않는다. 물리적 삭제를 위해서 컨테이너 내부에서 ‘garbage-collect 명령어를 수행하여 Registry GC를 수동으로 수행한다. 위의 1), 2)와 명시적 gc 수행 명령어는 이 글의 최하단의 ‘관련 명령어’ 를 참조하자. 1234567891011version: 0.1... storage: delete: enabled: false (-&gt; true 로 변경)... 2. Image에 삭제에 따른 storage 용량 확보위에서 소개한 것과 같이, docker image layer는 registry 내부의 모든 manifests 파일이 참조하지 않는 레이어에 대하여만 GC 시, 삭제를 수행한다. 이와 같이 여러개의 manifests 파일이 동일한 이미지 레이어를 참조하는 구조로 인하여, 특정 이미지를 삭제 하는 것이 disk 확보와 직결되지 않을 수 있다. 아래의 그림을 예시로 보자. image A와 image B는 서로 동일한 레이어를 포함하고 있다. 이와 같은 구조는 실제 도커 이미지를 빌드할 때, 같은 베이스 이미지를 사용하여 빌드를 계속 수행할 경우 나타날 수 있다. 이런 경우에 최종 빌드 이미지만을 남겨 놓기 위하여 image A를 삭제하는 경우 image B가 참조하고 있는 layer 들로 인하여 실제로 layer a,b,c 는 삭제 되지 않는다. 이와 다른 경우로 오른쪽의 그림을 보면 하나의 베이스 이미지로 여러가지 버전이 존재 한다. image C, D, E, F 중 일부를 삭제 하는 경우 해당 image에서만 사용하고 있는 레이어도 같이 삭제하여 디스크를 확보할 수 있다. 위와 같은 이미지 레이어의 참조 구조를 고려하여 도커 이미지를 빌드하거나 혹은 삭제하는 것이 좋다. #@# 3. Caching 기능에 따른 re-push 문제위와 같은 방식을 이용하면 특정 이미지를 물리적으로 제거할 수 있다. 하지만 이렇게 Registry GC를 수행한 후에 동일한 [이미지]:[태그]로 다시 push 할 경우에는 push가 수행 되는 것처럼 보이지만 내부적으로는 실제 push가 일어나지 않는다. 따라서 push 후에 동일한 이미지명으로 pull 할 경우에도 image가 존재하지 않는다는 오류가 발생한다. 이는 docker registry config에 caching 기능이 지정되어 있어 발생한다. Registry는 image layer에 접근을 빠르게 하기 위하여 caching 기능을 기본적으로 사용하며, inmemory, redis 등의 옵션으로 사용되어진다. 이 caching 기능을 없애기 위하여 registry config 파일에서 caching 과 관련된 항목을 제거한다. 반대로 caching을 기능 없애지 않는 경우에는, cache 를 수동으로 없애기 위하여 registry 컨테이너를 재시작하는 방법 또한 가능하다. 즉, 물리적 이미지 삭제 이후에 re-push가 되지 않는 문제를 해결하기 위해서는 1) in-memory cache를 지우기 위하여 registry 컨테이너를 재시작하거나, 2)구동하는 시점부터 cache 기능을 사용하지 않도록 설정하는 방법을 사용할 수 있다. (추가적으로 캐시 저장소를 redis를 사용하는 방법이 있으나 이는 별도로 기술한다.) 하지만 cache 를 없애기 위한 위 2가지 방식과 무관하게, disk size를 줄이기 위하여 수행해야 하는 GC 수행은 반드시 registry의 image로 구동되어 있는 container가 없으며, pull/push 가 일어나지 않는 중에 수행 되어야 한다. 그렇지 않을 경우, 기존 image가 깨지거나 pull/push 중이던 image가 손상될 수 있다. 결론위의 방법 중 어떤 방법을 사용하더라도, 실제로 GC가 일어나는 중에는 registry의 기능이 정지되어 있어야 한다. 어차피 GC를 위하여 registry의 기능을 사용하지 않는다면, 캐싱기능을 그대로 사용하고 registry를 재시작하는 방법을 권장한다. 결과적으로 registry 삭제를 통한 disk 확보는 docker image 의 multi-layer 구조를 고려하여 진행하는 것이 좋으며, 삭제하지 않을 경우에는 처음부터 충분한 공간의 storage를 확보하는 것이 좋다. 관련 명령어registry 와 관련된 API를 활용한 명령어는 아래와 같으며, 아래의 순서대로 차례대로 명령을 수행하여 해당 이미지를 논리적/물리적으로 삭제할 수 있다. 123456789101112131401. registry 내부의 repository 정보 조회$ curl -X GET &lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;_catalog02. repository 에 대하여 tag 정보 조회$ curl -X GET &lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;tags&#x2F;list03. content digest 조회$ curl -v --silent -H &quot;Accept: application&#x2F;vnd.docker.distribution.manifest.v2+json&quot; -X GET http:&#x2F;&#x2F;&lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;manifests&#x2F;&lt;TAG 이름&gt; 2&gt;&amp;1 | grep Docker-Content-Digest | awk &#39;&#123;print ($3)&#125;&#39;04. manifest 삭제$ curl -v --silent -H &quot;Accept: application&#x2F;vnd.docker.distribution.manifest.v2+json&quot; -X DELETE http:&#x2F;&#x2F;&lt;REGISTRY URL:포트&gt;&#x2F;v2&#x2F;&lt;REPOSITORY 이름&gt;&#x2F;manifests&#x2F;&lt;DIGEST 정보&gt;05. GC(Garbage Collection)$ docker exec -it registry_dev registry garbage-collect &#x2F;etc&#x2F;docker&#x2F;registry&#x2F;config.yml","categories":[],"tags":[]},{"title":"docker overview","slug":"docker-overview","date":"2020-11-18T23:50:09.000Z","updated":"2020-11-19T09:28:19.572Z","comments":true,"path":"2020/11/18/docker-overview/","link":"","permalink":"http://bluefriday.github.io/2020/11/18/docker-overview/","excerpt":"","text":"1. Container 기술과 Docker기존의 시스템 관리자들은 서비스를 제공하는 서버를 관리하기 위하여 VM(Virtual Machine, 가상머신)을 사용하여 자원을 관리해왔다. VM을 사용하는 서버 관리 방식은 물리적 서버를 직접 운영하는 것보다 효율적이었지만, Host OS 위에 Guest OS를 구동하는 구조로 인하여 가상화(hypervisor 레이어) 자체에 대한 비용이 존재하였다. 또한 서비스의 규모가 커지거나, 사용시간 등에 따라 사용량이 수시로 변경되면서 자원을 효율적으로 관리하기 위한 스케일에 대한 필요성도 증가하였다. 이러한 환경에서 등장한 컨테이너 기술은 Guest OS를 생성하여 시스템 자체를 가상화 하는 것이 아닌, 어플리케이션의 구동 환경을 가상화 하는 기술이다. 기존에 사용하던 VM이 Host OS 위에 Hypervisor Tool 을 이용하여 Guest OS 를 구동하는 것에 비해, 컨테이너 서비스는 Host OS 위에 직접 어플리케이션의 실행환경을 가상화 시켜준다. GuestOS 가 없기 때문에 VM에 비하여 가볍고 구동시간 또한 더 빠르다. 애초에 OS가 아니라 프로세스가 구동되는 개념이어서, 부팅 속도가 VM에 비해 더 빠를 수 밖에 없다. 이러한 이유로 컨테이너는 Lightweight VM 이라고도 불린다. 빠른 부팅 속도로 인하여 스케일링, fail-over 등에도 효율적이다.또한 Hypervisor 가 없이 바로 HostOS 의 자원을 사용할 수 있기 때문에 VM에 비해 더 효율적인 자원 사용이 가능하다. 정리하면 아래와 같은 장점을 가지고 있다고 볼 수 있다. 가상화 기술보다 가볍고 성능이 좋으면서도 동일한 Bard Metal/Virtual Machine 에서 더 많은 어플리케이션을 구동할 수 있다. 빠른 빌드와 배포, 이식성을 제공하므로 이를 통해서 개발을 더 쉽고 빠르게 할 수 있고 확장성을 높힐 수 있다. 개발에서 운영으로의 이관이 용이하며, DevOps 패러다임에 유리하다. Host Kernal 레벨을 공유하며 OS를 따로 부팅하지 않으므로 VM에 비하여 부팅속도가 매우 빠르다. 그러나 실제로는 GuestOS가 없다는 표현 보다는 HostOS를 Linux 로 고정 시킨 것에 가깝기 때문에, Linux OS 가 아닌 OS. 예를 들면 windows OS 에서만 작동하는 어플리케이션은 컨테이너로 구동할 수 없다는 단점도 있다. 이러한 장점과 단점을 가진 컨테이너 기술은 사실 갑자기 등장한 개념은 아니다. 서버 관리자들은 이미 chroot, namespace 등의 컨테이너를 구성하는 프로세스 격리 기술을 사용해 왔으며 최근에 사용성이 증가되면서 ‘컨테이너’ 라는 개념으로 새롭게 조명되고 있다. 즉, ‘빅데이터’나 ‘클라우드’와 같이 마케팅 성격이 다소 포함된 개념으로 볼 수 있다. 이 블로그에서 소개하고 있는 Docker 서비스는 Linux 환경에서 컨테이너 기술을 사용하기 쉽게 만들어놓은 시스템 프로그램(서비스)이다. 내부적으로 리눅스에 내장되어 있는 OS 레벨의 가상화 기술인 리눅스 컨테이너 기술(LXC)을 사용한다. Docker와 같은 컨테이너 서비스는 Linux 에서만 존재하는 기술은 아니며 이외의 Unix / BSD 계열에서도 컨테이너라는 명칭을 사용하지 않을 뿐 아래와 같은 가상화 기술을 제공하고 있다. Linux : Docker FreeBSD : Jails AIX : 워크로드 파티션(AIX Workload Partitions) Solaris : Zone 2. Docker installDocker는 리눅스에서 제공하는 컨테이너 서비스이므로 당연히 LInux 계열의 OS 인 Debian, Centos, Ubuntu 등의 OS에서 설치하는 것이 가장 쉽고 편하다. 추가적으로 Linux 이외의 Mac OS, Windows OS 등에서도 Docker를 설치할 수 있도록 가이드와 패키지를 제공하고 있다. Windows 에서 Docker를 설치 하기 위해서는 Windows 환경 위에 Linux OS 를 Guest로 구성해야 한다. 물론 Guest OS를 사용하지 않기 위한 것이 Docker 사용의 주요 목적이므로, docker를 설치하기 위해 Guest OS를 구성하는 것은 매우 비효율적이고 부자연스러운 방식이나 실 운영 서비스를 위해서가 아닌 개발 및 검증 목적으로 설치할 경우는 이와 같은 방식으로도 설치가 가능하다. 대부분의 경우 VMWare 나 Oracle Virtualbox 등의 hypervisor tool 을 설치하고 그 위에 Linus OS(ubuntu, centos)를 GuestOS로 구동하고 다시 그 안에서 도커를 설치한다. (전술했듯이 복잡하고 성능상으로는 다소 불리한 방법이니 테스트 등의 목적으로만 사용하는 것이 좋다.) 이와는 별개로 Docker 측에서는 위와 같은 작업을 이미 packaging 화하여 ‘Docker toolbox’라는 설치 패키지를 제공한다. 실제로 Docker Toolbox 안에는 Oracle virtualBox 가 포함되어 있다. 편한 방법을 사용하여 도커를 설치하도록 하자. 또한 Windows 10의 경우 docker toolbox 이외에 Docker for windows 라는 별도의 설치패키지를 지원한다. docker toolbox와 유사하나 windows에서 제공하는 windows container 를 위한 패키지가 추가 되었다고 보면 된다. (Docker container 가 host OS 가 linux 를 사용하는 것과 반대로 Windows container 는 host OS를 Windows로 사용한다고 보면 이해가 쉽다) 각각의 OS에서 Docker를 설치하는 링크나 패키지는 아래와 같으므로 필요에 따라 해당 내용을 검색하여 설치를 권장한다. Ubuntu : https://docs.docker.com/install/linux/docker-ce/ubuntu/ Centos : https://docs.docker.com/install/linux/docker-ce/centos/ Mac OS : Docker for Mac, Docker Toolbox Windows 7 : Docker Toolbox Windows 10 : Docker for windows 3. Docker version컨테이너 개념에 대하여 소개하면서 서술하였듯이, ‘컨테이너’라는 개념은 이미 존재하고 있는 시스템 개념이며 Docker는 이를 사용하기 쉽게 패키징한 서비스이다. Docker 진영은 2013년 1월에 0.1.0 버전으로 처음 release 하여 계속해서 버그를 수정하고 새로운 기능을 계속 추가해 오다가 1.6버전에서부터 enterprise 성격의 cs-docker(cs : Commercial Supported)를 출시한다. 또한 2017년에는 그 동안의 표기인 docker, cs-docker 를 docker-ce, docker-ee로 각각 변경하고 기존의 major / minor 버전 표기법을 year.month 의 연월 표기법으로 변경하여 사용한다. Docker-CE : Community 버전. 분기별로 새로운 버전이 출시되며, 실험적인 기능을 포함하고 있는 edge 버전이 매달 release 된다.Docker-EE : Enterprise 버전. 분기별로 새로운 버전이 출시된다.","categories":[],"tags":[]}],"categories":[],"tags":[]}